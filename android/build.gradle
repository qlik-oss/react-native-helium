import java.nio.file.Paths

buildscript {
  // Buildscript is evaluated before everything else so we can't use getExtOrDefault
  def kotlin_version = rootProject.ext.has('kotlinVersion') ? rootProject.ext.get('kotlinVersion') : project.properties['ReactNativeHelium_kotlinVersion']

  repositories {
    google()
    mavenCentral()
  }

  dependencies {
    classpath "com.android.tools.build:gradle:7.2.1"
    // noinspection DifferentKotlinGradleVersion
    classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"
  }
}

apply plugin: 'com.android.library'
apply plugin: 'kotlin-android'

def getExtOrDefault(name) {
  return rootProject.ext.has(name) ? rootProject.ext.get(name) : project.properties['ReactNativeHelium_' + name]
}

def getExtOrIntegerDefault(name) {
  return rootProject.ext.has(name) ? rootProject.ext.get(name) : (project.properties['ReactNativeHelium_' + name]).toInteger()
}

def findNodeModulePath(baseDir) {
  if (rootProject.hasProperty("heliumNodeModules")) {
    println "Using node modules $rootProject.ext.heliumNodeModules"
    return rootProject.ext.heliumNodeModules
  }
  def basePath = baseDir.toPath().normalize()
  // Node's module resolution algorithm searches up to the root directory,
  // after which the base path will be null
  while (basePath) {
    def nodeModulesPath = Paths.get(basePath.toString(), "node_modules")
    def reactNativePath = Paths.get(nodeModulesPath.toString(), "react-native")
    if (nodeModulesPath.toFile().exists() && reactNativePath.toFile().exists()) {
      return nodeModulesPath.toString()
    }
    basePath = basePath.getParent()
  }
  throw new GradleException("Failed to find node_modules/ path!")
}

def nodeModules = findNodeModulePath(projectDir);
logger.warn("node_modules/ found at: ${nodeModules}");

def prebuiltDir = rootProject.hasProperty("heliumNodeModules") ? "$nodeModules/react-native/ReactAndroid/src/main/jni/prebuilt/lib" : "$buildDir/react-native-0*/jni"
logger.warn("prebuiltDir/ found at: ${prebuiltDir}");


def rnAAR
android {
  compileSdkVersion getExtOrIntegerDefault('compileSdkVersion')
  buildToolsVersion getExtOrDefault('buildToolsVersion')

  configurations {
    extractHeaders
    extractJNI
  }

  defaultConfig {
    minSdkVersion 28
    targetSdkVersion getExtOrIntegerDefault('targetSdkVersion')
    versionCode 1
    versionName "1.0"

    externalNativeBuild {
      cmake {
        cppFlags "-O2 -frtti -fexceptions -Wall -fstack-protector-all"
        arguments "-DNODE_MODULES_DIR=${findNodeModulePath(projectDir)}"
        abiFilters 'arm64-v8a'
      }
    }
  }

  externalNativeBuild {
    cmake {
      path "CMakeLists.txt"
    }
  }

  buildTypes {
    release {
      minifyEnabled false
      rnAAR = fileTree(dir: "${rootDir}/../node_modules/react-native/android/", include:'**/react-native/**/*release.aar' ).singleFile
    }
    debug {
      rnAAR = fileTree(dir: "${rootDir}/../node_modules/react-native/android/", include:'**/react-native/**/*debug.aar' ).singleFile
    }
  }
  lintOptions {
    disable 'GradleCompatible'
  }

   packagingOptions {
        excludes = [
             "**/libc++_shared.so",
             "**/libfbjni.so",
             "**/libjsi.so",
             "**/libreact_nativemodule_core.so",
             "**/libturbomodulejsijni.so"
        ]
    }

  compileOptions {
    sourceCompatibility JavaVersion.VERSION_11
    targetCompatibility JavaVersion.VERSION_11
  }

}

repositories {
  mavenCentral()
  mavenLocal()
  google()
}

def kotlin_version = getExtOrDefault('kotlinVersion')

dependencies {
  // noinspection GradleDynamicVersion
  api 'com.facebook.react:react-native:+'
  implementation "org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version"
  // If headers are required.
  extractHeaders 'com.facebook.fbjni:fbjni:0.2.2:headers'
  // If the `.so` files are required for linking.
  extractJNI 'com.facebook.fbjni:fbjni:0.3.0'
  extractJNI(files(rnAAR))
}

task extractAARHeaders {
  doLast {
    configurations.extractHeaders.files.each {
      def file = it.absoluteFile
      copy {
        from zipTree(file)
        into "$buildDir/$file.name"
        include "**/*.h"
      }
    }
  }
}

task extractJNIFiles {
  doLast {
    configurations.extractJNI.files.each {
      def file = it.absoluteFile
      copy {
        from zipTree(file)
        into "$buildDir/$file.name"
        include "jni/**/*"
      }
    }
  }
}

extractJNIFiles.mustRunAfter extractAARHeaders

def nativeBuildDependsOn(dependsOnTask, variant) {
  def buildTasks = tasks.findAll({ task ->
      !task.name.contains("Clean") && (task.name.contains("externalNative") || task.name.contains("CMake")) })
  if (variant != null) {
    buildTasks = buildTasks.findAll({ task -> task.name.contains(variant) })
  }
  buildTasks.forEach { task -> task.dependsOn(dependsOnTask) }
}

afterEvaluate {
  nativeBuildDependsOn(extractAARHeaders, null)
  nativeBuildDependsOn(extractJNIFiles, null)
}
